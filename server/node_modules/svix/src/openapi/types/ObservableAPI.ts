import { ResponseContext, RequestContext, HttpFile } from '../http/http';
import * as models from '../models/all';
import { Configuration} from '../configuration'
import { Observable, of, from } from '../rxjsStub';
import {mergeMap, map} from  '../rxjsStub';
import { AggregateEventTypesOut } from '../models/AggregateEventTypesOut';
import { AppPortalAccessIn } from '../models/AppPortalAccessIn';
import { AppPortalAccessOut } from '../models/AppPortalAccessOut';
import { AppUsageStatsIn } from '../models/AppUsageStatsIn';
import { AppUsageStatsOut } from '../models/AppUsageStatsOut';
import { ApplicationIn } from '../models/ApplicationIn';
import { ApplicationOut } from '../models/ApplicationOut';
import { ApplicationPatch } from '../models/ApplicationPatch';
import { ApplicationStats } from '../models/ApplicationStats';
import { ApplicationTokenExpireIn } from '../models/ApplicationTokenExpireIn';
import { AttemptStatisticsData } from '../models/AttemptStatisticsData';
import { AttemptStatisticsResponse } from '../models/AttemptStatisticsResponse';
import { AuthTokenOut } from '../models/AuthTokenOut';
import { AzureBlobStorageConfig } from '../models/AzureBlobStorageConfig';
import { BackgroundTaskOut } from '../models/BackgroundTaskOut';
import { BackgroundTaskStatus } from '../models/BackgroundTaskStatus';
import { BackgroundTaskType } from '../models/BackgroundTaskType';
import { BorderRadiusConfig } from '../models/BorderRadiusConfig';
import { BorderRadiusEnum } from '../models/BorderRadiusEnum';
import { ClientSecretJwtParamsIn } from '../models/ClientSecretJwtParamsIn';
import { CompletionChoice } from '../models/CompletionChoice';
import { CompletionMessage } from '../models/CompletionMessage';
import { CreateMessageTokenIn } from '../models/CreateMessageTokenIn';
import { CreateStreamIn } from '../models/CreateStreamIn';
import { CustomColorPalette } from '../models/CustomColorPalette';
import { CustomStringsOverride } from '../models/CustomStringsOverride';
import { CustomThemeOverride } from '../models/CustomThemeOverride';
import { DashboardAccessOut } from '../models/DashboardAccessOut';
import { Duration } from '../models/Duration';
import { EndpointCreatedEvent } from '../models/EndpointCreatedEvent';
import { EndpointCreatedEventData } from '../models/EndpointCreatedEventData';
import { EndpointDeletedEvent } from '../models/EndpointDeletedEvent';
import { EndpointDeletedEventData } from '../models/EndpointDeletedEventData';
import { EndpointDisabledEvent } from '../models/EndpointDisabledEvent';
import { EndpointDisabledEventData } from '../models/EndpointDisabledEventData';
import { EndpointHeadersIn } from '../models/EndpointHeadersIn';
import { EndpointHeadersOut } from '../models/EndpointHeadersOut';
import { EndpointHeadersPatchIn } from '../models/EndpointHeadersPatchIn';
import { EndpointIn } from '../models/EndpointIn';
import { EndpointMessageOut } from '../models/EndpointMessageOut';
import { EndpointMtlsConfigIn } from '../models/EndpointMtlsConfigIn';
import { EndpointOauthConfigIn } from '../models/EndpointOauthConfigIn';
import { EndpointOut } from '../models/EndpointOut';
import { EndpointPatch } from '../models/EndpointPatch';
import { EndpointSecretOut } from '../models/EndpointSecretOut';
import { EndpointSecretRotateIn } from '../models/EndpointSecretRotateIn';
import { EndpointStats } from '../models/EndpointStats';
import { EndpointTransformationIn } from '../models/EndpointTransformationIn';
import { EndpointTransformationOut } from '../models/EndpointTransformationOut';
import { EndpointTransformationSimulateIn } from '../models/EndpointTransformationSimulateIn';
import { EndpointTransformationSimulateOut } from '../models/EndpointTransformationSimulateOut';
import { EndpointUpdate } from '../models/EndpointUpdate';
import { EndpointUpdatedEvent } from '../models/EndpointUpdatedEvent';
import { EndpointUpdatedEventData } from '../models/EndpointUpdatedEventData';
import { EnvironmentIn } from '../models/EnvironmentIn';
import { EnvironmentOut } from '../models/EnvironmentOut';
import { EnvironmentSettingsOut } from '../models/EnvironmentSettingsOut';
import { EventExampleIn } from '../models/EventExampleIn';
import { EventIn } from '../models/EventIn';
import { EventOut } from '../models/EventOut';
import { EventStreamOut } from '../models/EventStreamOut';
import { EventTypeExampleOut } from '../models/EventTypeExampleOut';
import { EventTypeFromOpenApi } from '../models/EventTypeFromOpenApi';
import { EventTypeImportOpenApiIn } from '../models/EventTypeImportOpenApiIn';
import { EventTypeImportOpenApiOut } from '../models/EventTypeImportOpenApiOut';
import { EventTypeImportOpenApiOutData } from '../models/EventTypeImportOpenApiOutData';
import { EventTypeIn } from '../models/EventTypeIn';
import { EventTypeOut } from '../models/EventTypeOut';
import { EventTypePatch } from '../models/EventTypePatch';
import { EventTypeSchemaIn } from '../models/EventTypeSchemaIn';
import { EventTypeUpdate } from '../models/EventTypeUpdate';
import { ExportEventTypeOut } from '../models/ExportEventTypeOut';
import { FontSizeConfig } from '../models/FontSizeConfig';
import { GenerateIn } from '../models/GenerateIn';
import { GenerateOut } from '../models/GenerateOut';
import { GoogleCloudStorageConfig } from '../models/GoogleCloudStorageConfig';
import { HTTPValidationError } from '../models/HTTPValidationError';
import { HttpErrorOut } from '../models/HttpErrorOut';
import { HubspotOauthConfigIn } from '../models/HubspotOauthConfigIn';
import { InboundPathParams } from '../models/InboundPathParams';
import { IncomingWebhookPayloadOut } from '../models/IncomingWebhookPayloadOut';
import { IntegrationIn } from '../models/IntegrationIn';
import { IntegrationKeyOut } from '../models/IntegrationKeyOut';
import { IntegrationOut } from '../models/IntegrationOut';
import { IntegrationUpdate } from '../models/IntegrationUpdate';
import { KafkaSecurityProtocolType } from '../models/KafkaSecurityProtocolType';
import { ListResponseApplicationOut } from '../models/ListResponseApplicationOut';
import { ListResponseApplicationStats } from '../models/ListResponseApplicationStats';
import { ListResponseBackgroundTaskOut } from '../models/ListResponseBackgroundTaskOut';
import { ListResponseEndpointMessageOut } from '../models/ListResponseEndpointMessageOut';
import { ListResponseEndpointOut } from '../models/ListResponseEndpointOut';
import { ListResponseEventTypeOut } from '../models/ListResponseEventTypeOut';
import { ListResponseIntegrationOut } from '../models/ListResponseIntegrationOut';
import { ListResponseMessageAttemptEndpointOut } from '../models/ListResponseMessageAttemptEndpointOut';
import { ListResponseMessageAttemptOut } from '../models/ListResponseMessageAttemptOut';
import { ListResponseMessageEndpointOut } from '../models/ListResponseMessageEndpointOut';
import { ListResponseMessageOut } from '../models/ListResponseMessageOut';
import { ListResponseSinkOut } from '../models/ListResponseSinkOut';
import { ListResponseStreamOut } from '../models/ListResponseStreamOut';
import { ListResponseStreamSinkOut } from '../models/ListResponseStreamSinkOut';
import { ListResponseTemplateOut } from '../models/ListResponseTemplateOut';
import { MessageAttemptEndpointOut } from '../models/MessageAttemptEndpointOut';
import { MessageAttemptExhaustedEvent } from '../models/MessageAttemptExhaustedEvent';
import { MessageAttemptExhaustedEventData } from '../models/MessageAttemptExhaustedEventData';
import { MessageAttemptFailedData } from '../models/MessageAttemptFailedData';
import { MessageAttemptFailingEvent } from '../models/MessageAttemptFailingEvent';
import { MessageAttemptFailingEventData } from '../models/MessageAttemptFailingEventData';
import { MessageAttemptHeadersOut } from '../models/MessageAttemptHeadersOut';
import { MessageAttemptOut } from '../models/MessageAttemptOut';
import { MessageAttemptRecoveredEvent } from '../models/MessageAttemptRecoveredEvent';
import { MessageAttemptRecoveredEventData } from '../models/MessageAttemptRecoveredEventData';
import { MessageAttemptTriggerType } from '../models/MessageAttemptTriggerType';
import { MessageBroadcastIn } from '../models/MessageBroadcastIn';
import { MessageBroadcastOut } from '../models/MessageBroadcastOut';
import { MessageEndpointOut } from '../models/MessageEndpointOut';
import { MessageEventsOut } from '../models/MessageEventsOut';
import { MessageIn } from '../models/MessageIn';
import { MessageOut } from '../models/MessageOut';
import { MessageRawPayloadOut } from '../models/MessageRawPayloadOut';
import { MessageStatus } from '../models/MessageStatus';
import { MessageSubscriberAuthTokenOut } from '../models/MessageSubscriberAuthTokenOut';
import { OAuthPayloadIn } from '../models/OAuthPayloadIn';
import { OAuthPayloadOut } from '../models/OAuthPayloadOut';
import { Oauth2AuthMethodIn } from '../models/Oauth2AuthMethodIn';
import { Oauth2GrantTypeIn } from '../models/Oauth2GrantTypeIn';
import { OauthJwsSigningAlgorithm } from '../models/OauthJwsSigningAlgorithm';
import { OneTimeTokenIn } from '../models/OneTimeTokenIn';
import { OneTimeTokenOut } from '../models/OneTimeTokenOut';
import { Ordering } from '../models/Ordering';
import { RecoverIn } from '../models/RecoverIn';
import { RecoverOut } from '../models/RecoverOut';
import { RedshiftConfig } from '../models/RedshiftConfig';
import { ReplayIn } from '../models/ReplayIn';
import { ReplayOut } from '../models/ReplayOut';
import { RetryScheduleInOut } from '../models/RetryScheduleInOut';
import { RotatedUrlOut } from '../models/RotatedUrlOut';
import { S3Config } from '../models/S3Config';
import { SettingsIn } from '../models/SettingsIn';
import { SettingsOut } from '../models/SettingsOut';
import { SinkHttpConfig } from '../models/SinkHttpConfig';
import { SinkIn } from '../models/SinkIn';
import { SinkInOneOf } from '../models/SinkInOneOf';
import { SinkInOneOf1 } from '../models/SinkInOneOf1';
import { SinkInOneOf2 } from '../models/SinkInOneOf2';
import { SinkInOneOf3 } from '../models/SinkInOneOf3';
import { SinkOtelV1Config } from '../models/SinkOtelV1Config';
import { SinkOut } from '../models/SinkOut';
import { SinkPayloadFormat } from '../models/SinkPayloadFormat';
import { SinkStatus } from '../models/SinkStatus';
import { SinkStatusIn } from '../models/SinkStatusIn';
import { SinkTransformIn } from '../models/SinkTransformIn';
import { SinkTransformationOut } from '../models/SinkTransformationOut';
import { SnowflakeConfig } from '../models/SnowflakeConfig';
import { StatisticsPeriod } from '../models/StatisticsPeriod';
import { StatusCodeClass } from '../models/StatusCodeClass';
import { StreamIn } from '../models/StreamIn';
import { StreamOut } from '../models/StreamOut';
import { StreamPatch } from '../models/StreamPatch';
import { StreamSinkIn } from '../models/StreamSinkIn';
import { StreamSinkInOneOf } from '../models/StreamSinkInOneOf';
import { StreamSinkInOneOf1 } from '../models/StreamSinkInOneOf1';
import { StreamSinkInOneOf2 } from '../models/StreamSinkInOneOf2';
import { StreamSinkInOneOf3 } from '../models/StreamSinkInOneOf3';
import { StreamSinkInOneOf4 } from '../models/StreamSinkInOneOf4';
import { StreamSinkInOneOf5 } from '../models/StreamSinkInOneOf5';
import { StreamSinkInOneOf6 } from '../models/StreamSinkInOneOf6';
import { StreamSinkOut } from '../models/StreamSinkOut';
import { StreamSinkPatch } from '../models/StreamSinkPatch';
import { TemplateIn } from '../models/TemplateIn';
import { TemplateOut } from '../models/TemplateOut';
import { TemplatePatch } from '../models/TemplatePatch';
import { TemplateUpdate } from '../models/TemplateUpdate';
import { TransformationHttpMethod } from '../models/TransformationHttpMethod';
import { TransformationSimulateIn } from '../models/TransformationSimulateIn';
import { TransformationSimulateOut } from '../models/TransformationSimulateOut';
import { TransformationTemplateKind } from '../models/TransformationTemplateKind';
import { ValidationError } from '../models/ValidationError';

import { ApplicationApiRequestFactory, ApplicationApiResponseProcessor} from "../apis/ApplicationApi";
export class ObservableApplicationApi {
    private requestFactory: ApplicationApiRequestFactory;
    private responseProcessor: ApplicationApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: ApplicationApiRequestFactory,
        responseProcessor?: ApplicationApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new ApplicationApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new ApplicationApiResponseProcessor();
    }

    /**
     * Get basic statistics for all applications.
     * Get App Usage Stats
     * @param since Filter the range to data after this date
     * @param until Filter the range to data before this date
     * @param limit Limit the number of returned items
     * @param iterator The iterator to use (depends on the chosen ordering)
     */
    public getAppUsageStatsApiV1AppStatsUsageGet(since: Date, until: Date, limit?: number, iterator?: string, _options?: Configuration): Observable<ListResponseApplicationStats> {
        const requestContextPromise = this.requestFactory.getAppUsageStatsApiV1AppStatsUsageGet(since, until, limit, iterator, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getAppUsageStatsApiV1AppStatsUsageGet(rsp)));
            }));
    }
 
    /**
     * Create a new application.
     * Create Application
     * @param applicationIn 
     * @param getIfExists Get an existing application, or create a new one if doesn&#39;t exist. It&#39;s two separate functions in the libs.
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1ApplicationCreate(applicationIn: ApplicationIn, getIfExists?: boolean, idempotencyKey?: string, _options?: Configuration): Observable<ApplicationOut> {
        const requestContextPromise = this.requestFactory.v1ApplicationCreate(applicationIn, getIfExists, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1ApplicationCreate(rsp)));
            }));
    }
 
    /**
     * Delete an application.
     * Delete Application
     * @param appId The app&#39;s ID or UID
     */
    public v1ApplicationDelete(appId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1ApplicationDelete(appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1ApplicationDelete(rsp)));
            }));
    }
 
    /**
     * Get an application.
     * Get Application
     * @param appId The app&#39;s ID or UID
     */
    public v1ApplicationGet(appId: string, _options?: Configuration): Observable<ApplicationOut> {
        const requestContextPromise = this.requestFactory.v1ApplicationGet(appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1ApplicationGet(rsp)));
            }));
    }
 
    /**
     * Get basic statistics for the application
     * Get App Stats
     * @param since Filter the range to data starting from this date
     * @param until Filter the range to data ending by this date
     * @param appId The app&#39;s ID or UID
     */
    public v1ApplicationGetStats(since: Date, until: Date, appId: string, _options?: Configuration): Observable<ApplicationStats> {
        const requestContextPromise = this.requestFactory.v1ApplicationGetStats(since, until, appId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1ApplicationGetStats(rsp)));
            }));
    }
 
    /**
     * List of all the organization's applications.
     * List Applications
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     */
    public v1ApplicationList(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Observable<ListResponseApplicationOut> {
        const requestContextPromise = this.requestFactory.v1ApplicationList(limit, iterator, order, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1ApplicationList(rsp)));
            }));
    }
 
    /**
     * Partially update an application.
     * Patch Application
     * @param appId The app&#39;s ID or UID
     * @param applicationPatch 
     */
    public v1ApplicationPatch(appId: string, applicationPatch: ApplicationPatch, _options?: Configuration): Observable<ApplicationOut> {
        const requestContextPromise = this.requestFactory.v1ApplicationPatch(appId, applicationPatch, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1ApplicationPatch(rsp)));
            }));
    }
 
    /**
     * Update an application.
     * Update Application
     * @param appId The app&#39;s ID or UID
     * @param applicationIn 
     */
    public v1ApplicationUpdate(appId: string, applicationIn: ApplicationIn, _options?: Configuration): Observable<ApplicationOut> {
        const requestContextPromise = this.requestFactory.v1ApplicationUpdate(appId, applicationIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1ApplicationUpdate(rsp)));
            }));
    }
 
}

import { AuthenticationApiRequestFactory, AuthenticationApiResponseProcessor} from "../apis/AuthenticationApi";
export class ObservableAuthenticationApi {
    private requestFactory: AuthenticationApiRequestFactory;
    private responseProcessor: AuthenticationApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: AuthenticationApiRequestFactory,
        responseProcessor?: AuthenticationApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new AuthenticationApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new AuthenticationApiResponseProcessor();
    }

    /**
     * Use this function to get magic links (and authentication codes) for connecting your users to the Consumer Application Portal.
     * Get Consumer App Portal Access
     * @param appId The app&#39;s ID or UID
     * @param appPortalAccessIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1AuthenticationAppPortalAccess(appId: string, appPortalAccessIn: AppPortalAccessIn, idempotencyKey?: string, _options?: Configuration): Observable<AppPortalAccessOut> {
        const requestContextPromise = this.requestFactory.v1AuthenticationAppPortalAccess(appId, appPortalAccessIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AuthenticationAppPortalAccess(rsp)));
            }));
    }
 
    /**
     * Create a new access token that only allows creating messages inside this application.
     * Create Cmg Token
     * @param appId The app&#39;s ID or UID
     * @param createMessageTokenIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1AuthenticationCreateMessageToken(appId: string, createMessageTokenIn: CreateMessageTokenIn, idempotencyKey?: string, _options?: Configuration): Observable<AuthTokenOut> {
        const requestContextPromise = this.requestFactory.v1AuthenticationCreateMessageToken(appId, createMessageTokenIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AuthenticationCreateMessageToken(rsp)));
            }));
    }
 
    /**
     * DEPRECATED: Please use `app-portal-access` instead.  Use this function to get magic links (and authentication codes) for connecting your users to the Consumer Application Portal.
     * Dashboard Access
     * @param appId The app&#39;s ID or UID
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1AuthenticationDashboardAccess(appId: string, idempotencyKey?: string, _options?: Configuration): Observable<DashboardAccessOut> {
        const requestContextPromise = this.requestFactory.v1AuthenticationDashboardAccess(appId, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AuthenticationDashboardAccess(rsp)));
            }));
    }
 
    /**
     * This is a one time token
     * Exchange One Time Token
     * @param oneTimeTokenIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1AuthenticationExchangeOneTimeToken(oneTimeTokenIn: OneTimeTokenIn, idempotencyKey?: string, _options?: Configuration): Observable<OneTimeTokenOut> {
        const requestContextPromise = this.requestFactory.v1AuthenticationExchangeOneTimeToken(oneTimeTokenIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AuthenticationExchangeOneTimeToken(rsp)));
            }));
    }
 
    /**
     * Expire all of the tokens associated with a specific Application
     * Expire All
     * @param appId The app&#39;s ID or UID
     * @param applicationTokenExpireIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1AuthenticationExpireAll(appId: string, applicationTokenExpireIn: ApplicationTokenExpireIn, idempotencyKey?: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1AuthenticationExpireAll(appId, applicationTokenExpireIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AuthenticationExpireAll(rsp)));
            }));
    }
 
    /**
     * Logout an app token.  Trying to log out other tokens will fail.
     * Logout
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1AuthenticationLogout(idempotencyKey?: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1AuthenticationLogout(idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1AuthenticationLogout(rsp)));
            }));
    }
 
}

import { BackgroundTasksApiRequestFactory, BackgroundTasksApiResponseProcessor} from "../apis/BackgroundTasksApi";
export class ObservableBackgroundTasksApi {
    private requestFactory: BackgroundTasksApiRequestFactory;
    private responseProcessor: BackgroundTasksApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BackgroundTasksApiRequestFactory,
        responseProcessor?: BackgroundTasksApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BackgroundTasksApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BackgroundTasksApiResponseProcessor();
    }

    /**
     * Get a background task by ID.
     * Get Background Task
     * @param taskId 
     */
    public getBackgroundTask(taskId: string, _options?: Configuration): Observable<BackgroundTaskOut> {
        const requestContextPromise = this.requestFactory.getBackgroundTask(taskId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getBackgroundTask(rsp)));
            }));
    }
 
    /**
     * List background tasks executed in the past 90 days.
     * List Background Tasks
     * @param status Filter the response based on the status
     * @param task Filter the response based on the type
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     */
    public listBackgroundTasks(status?: BackgroundTaskStatus, task?: BackgroundTaskType, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Observable<ListResponseBackgroundTaskOut> {
        const requestContextPromise = this.requestFactory.listBackgroundTasks(status, task, limit, iterator, order, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.listBackgroundTasks(rsp)));
            }));
    }
 
}

import { BroadcastApiRequestFactory, BroadcastApiResponseProcessor} from "../apis/BroadcastApi";
export class ObservableBroadcastApi {
    private requestFactory: BroadcastApiRequestFactory;
    private responseProcessor: BroadcastApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: BroadcastApiRequestFactory,
        responseProcessor?: BroadcastApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new BroadcastApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new BroadcastApiResponseProcessor();
    }

    /**
     * Creates a background task to send the same message to each application in your organization
     * Create Broadcast Message
     * @param messageBroadcastIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public createBroadcastMessage(messageBroadcastIn: MessageBroadcastIn, idempotencyKey?: string, _options?: Configuration): Observable<MessageBroadcastOut> {
        const requestContextPromise = this.requestFactory.createBroadcastMessage(messageBroadcastIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createBroadcastMessage(rsp)));
            }));
    }
 
}

import { EndpointApiRequestFactory, EndpointApiResponseProcessor} from "../apis/EndpointApi";
export class ObservableEndpointApi {
    private requestFactory: EndpointApiRequestFactory;
    private responseProcessor: EndpointApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: EndpointApiRequestFactory,
        responseProcessor?: EndpointApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new EndpointApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new EndpointApiResponseProcessor();
    }

    /**
     * Create a new endpoint for the application.  When `secret` is `null` the secret is automatically generated (recommended)
     * Create Endpoint
     * @param appId The app&#39;s ID or UID
     * @param endpointIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EndpointCreate(appId: string, endpointIn: EndpointIn, idempotencyKey?: string, _options?: Configuration): Observable<EndpointOut> {
        const requestContextPromise = this.requestFactory.v1EndpointCreate(appId, endpointIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointCreate(rsp)));
            }));
    }
 
    /**
     * Delete an endpoint.
     * Delete Endpoint
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     */
    public v1EndpointDelete(appId: string, endpointId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointDelete(appId, endpointId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointDelete(rsp)));
            }));
    }
 
    /**
     * Delete endpoint mTLS configuration
     * Delete Endpoint Mtls Config
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     */
    public v1EndpointDeleteMtlsConfig(appId: string, endpointId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointDeleteMtlsConfig(appId, endpointId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointDeleteMtlsConfig(rsp)));
            }));
    }
 
    /**
     * Delete endpoint OAuth configuration
     * Delete Endpoint Oauth Config
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     */
    public v1EndpointDeleteOauthConfig(appId: string, endpointId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointDeleteOauthConfig(appId, endpointId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointDeleteOauthConfig(rsp)));
            }));
    }
 
    /**
     * Get an endpoint.
     * Get Endpoint
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     */
    public v1EndpointGet(appId: string, endpointId: string, _options?: Configuration): Observable<EndpointOut> {
        const requestContextPromise = this.requestFactory.v1EndpointGet(appId, endpointId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointGet(rsp)));
            }));
    }
 
    /**
     * Get the additional headers to be sent with the webhook
     * Get Endpoint Headers
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     */
    public v1EndpointGetHeaders(appId: string, endpointId: string, _options?: Configuration): Observable<EndpointHeadersOut> {
        const requestContextPromise = this.requestFactory.v1EndpointGetHeaders(appId, endpointId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointGetHeaders(rsp)));
            }));
    }
 
    /**
     * Get the endpoint's signing secret.  This is used to verify the authenticity of the webhook. For more information please refer to [the consuming webhooks docs](https://docs.svix.com/consuming-webhooks/).
     * Get Endpoint Secret
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     */
    public v1EndpointGetSecret(appId: string, endpointId: string, _options?: Configuration): Observable<EndpointSecretOut> {
        const requestContextPromise = this.requestFactory.v1EndpointGetSecret(appId, endpointId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointGetSecret(rsp)));
            }));
    }
 
    /**
     * Get basic statistics for the endpoint.
     * Endpoint Stats
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param since Filter the range to data starting from this date
     * @param until Filter the range to data ending by this date
     */
    public v1EndpointGetStats(appId: string, endpointId: string, since?: Date, until?: Date, _options?: Configuration): Observable<EndpointStats> {
        const requestContextPromise = this.requestFactory.v1EndpointGetStats(appId, endpointId, since, until, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointGetStats(rsp)));
            }));
    }
 
    /**
     * List the application's endpoints.
     * List Endpoints
     * @param appId The app&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     */
    public v1EndpointList(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Observable<ListResponseEndpointOut> {
        const requestContextPromise = this.requestFactory.v1EndpointList(appId, limit, iterator, order, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointList(rsp)));
            }));
    }
 
    /**
     * Partially update an endpoint.
     * Patch Endpoint
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointPatch 
     */
    public v1EndpointPatch(appId: string, endpointId: string, endpointPatch: EndpointPatch, _options?: Configuration): Observable<EndpointOut> {
        const requestContextPromise = this.requestFactory.v1EndpointPatch(appId, endpointId, endpointPatch, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointPatch(rsp)));
            }));
    }
 
    /**
     * Partially set the additional headers to be sent with the webhook
     * Patch Endpoint Headers
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointHeadersPatchIn 
     */
    public v1EndpointPatchHeaders(appId: string, endpointId: string, endpointHeadersPatchIn: EndpointHeadersPatchIn, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointPatchHeaders(appId, endpointId, endpointHeadersPatchIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointPatchHeaders(rsp)));
            }));
    }
 
    /**
     * Resend all failed messages since a given time.
     * Recover Failed Webhooks
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param recoverIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EndpointRecover(appId: string, endpointId: string, recoverIn: RecoverIn, idempotencyKey?: string, _options?: Configuration): Observable<RecoverOut> {
        const requestContextPromise = this.requestFactory.v1EndpointRecover(appId, endpointId, recoverIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointRecover(rsp)));
            }));
    }
 
    /**
     * Replays messages to the endpoint. Only messages that were created after `since` will be sent. Messages that were previously sent to the endpoint are not resent.
     * Replay Missing Webhooks
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param replayIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EndpointReplay(appId: string, endpointId: string, replayIn: ReplayIn, idempotencyKey?: string, _options?: Configuration): Observable<ReplayOut> {
        const requestContextPromise = this.requestFactory.v1EndpointReplay(appId, endpointId, replayIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointReplay(rsp)));
            }));
    }
 
    /**
     * Rotates the endpoint's signing secret.  The previous secret will be valid for the next 24 hours.
     * Rotate Endpoint Secret
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointSecretRotateIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EndpointRotateSecret(appId: string, endpointId: string, endpointSecretRotateIn: EndpointSecretRotateIn, idempotencyKey?: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointRotateSecret(appId, endpointId, endpointSecretRotateIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointRotateSecret(rsp)));
            }));
    }
 
    /**
     * Send an example message for an event
     * Send Event Type Example Message
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param eventExampleIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EndpointSendExample(appId: string, endpointId: string, eventExampleIn: EventExampleIn, idempotencyKey?: string, _options?: Configuration): Observable<MessageOut> {
        const requestContextPromise = this.requestFactory.v1EndpointSendExample(appId, endpointId, eventExampleIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointSendExample(rsp)));
            }));
    }
 
    /**
     * Get the transformation code associated with this endpoint
     * Get Endpoint Transformation
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     */
    public v1EndpointTransformationGet(appId: string, endpointId: string, _options?: Configuration): Observable<EndpointTransformationOut> {
        const requestContextPromise = this.requestFactory.v1EndpointTransformationGet(appId, endpointId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointTransformationGet(rsp)));
            }));
    }
 
    /**
     * Set or unset the transformation code associated with this endpoint
     * Set Endpoint Transformation
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointTransformationIn 
     */
    public v1EndpointTransformationPartialUpdate(appId: string, endpointId: string, endpointTransformationIn: EndpointTransformationIn, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointTransformationPartialUpdate(appId, endpointId, endpointTransformationIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointTransformationPartialUpdate(rsp)));
            }));
    }
 
    /**
     * Simulate running the transformation on the payload and code
     * Simulate
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointTransformationSimulateIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EndpointTransformationSimulate(appId: string, endpointId: string, endpointTransformationSimulateIn: EndpointTransformationSimulateIn, idempotencyKey?: string, _options?: Configuration): Observable<EndpointTransformationSimulateOut> {
        const requestContextPromise = this.requestFactory.v1EndpointTransformationSimulate(appId, endpointId, endpointTransformationSimulateIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointTransformationSimulate(rsp)));
            }));
    }
 
    /**
     * Update an endpoint.
     * Update Endpoint
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointUpdate 
     */
    public v1EndpointUpdate(appId: string, endpointId: string, endpointUpdate: EndpointUpdate, _options?: Configuration): Observable<EndpointOut> {
        const requestContextPromise = this.requestFactory.v1EndpointUpdate(appId, endpointId, endpointUpdate, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointUpdate(rsp)));
            }));
    }
 
    /**
     * Set the additional headers to be sent with the webhook
     * Update Endpoint Headers
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointHeadersIn 
     */
    public v1EndpointUpdateHeaders(appId: string, endpointId: string, endpointHeadersIn: EndpointHeadersIn, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointUpdateHeaders(appId, endpointId, endpointHeadersIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointUpdateHeaders(rsp)));
            }));
    }
 
    /**
     * Create/update endpoint mTLS configuration
     * Update Endpoint Mtls Config
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointMtlsConfigIn 
     */
    public v1EndpointUpdateMtlsConfig(appId: string, endpointId: string, endpointMtlsConfigIn: EndpointMtlsConfigIn, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointUpdateMtlsConfig(appId, endpointId, endpointMtlsConfigIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointUpdateMtlsConfig(rsp)));
            }));
    }
 
    /**
     * Create/update endpoint OAuth configuration
     * Update Endpoint Oauth Config
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param endpointOauthConfigIn 
     */
    public v1EndpointUpdateOauthConfig(appId: string, endpointId: string, endpointOauthConfigIn: EndpointOauthConfigIn, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointUpdateOauthConfig(appId, endpointId, endpointOauthConfigIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointUpdateOauthConfig(rsp)));
            }));
    }
 
    /**
     * Create a new sink for the application.
     * Create Sink
     * @param appId The app&#39;s ID or UID
     * @param sinkIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1SinkCreate(appId: string, sinkIn: SinkIn, idempotencyKey?: string, _options?: Configuration): Observable<SinkOut> {
        const requestContextPromise = this.requestFactory.v1SinkCreate(appId, sinkIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1SinkCreate(rsp)));
            }));
    }
 
    /**
     * Get a sink.
     * Get Sink
     * @param appId The app&#39;s ID or UID
     * @param sinkId The ep&#39;s ID or UID
     */
    public v1SinkGet(appId: string, sinkId: string, _options?: Configuration): Observable<SinkOut> {
        const requestContextPromise = this.requestFactory.v1SinkGet(appId, sinkId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1SinkGet(rsp)));
            }));
    }
 
    /**
     * List the application's sinks.
     * List Sinks
     * @param appId The app&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     */
    public v1SinkList(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Observable<ListResponseSinkOut> {
        const requestContextPromise = this.requestFactory.v1SinkList(appId, limit, iterator, order, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1SinkList(rsp)));
            }));
    }
 
}

import { EnvironmentApiRequestFactory, EnvironmentApiResponseProcessor} from "../apis/EnvironmentApi";
export class ObservableEnvironmentApi {
    private requestFactory: EnvironmentApiRequestFactory;
    private responseProcessor: EnvironmentApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: EnvironmentApiRequestFactory,
        responseProcessor?: EnvironmentApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new EnvironmentApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new EnvironmentApiResponseProcessor();
    }

    /**
     * Download a JSON file containing all org-settings and event types
     * Export Environment Configuration
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EnvironmentExport(idempotencyKey?: string, _options?: Configuration): Observable<EnvironmentOut> {
        const requestContextPromise = this.requestFactory.v1EnvironmentExport(idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EnvironmentExport(rsp)));
            }));
    }
 
    /**
     * Download a JSON file containing all org-settings and event types
     * Export Environment Configuration
     */
    public v1EnvironmentExportGet(_options?: Configuration): Observable<EnvironmentOut> {
        const requestContextPromise = this.requestFactory.v1EnvironmentExportGet(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EnvironmentExportGet(rsp)));
            }));
    }
 
    /**
     * Import a configuration into the active organization. It doesn't delete anything, only adds/updates what was passed to it.
     * Import Environment Configuration
     * @param environmentIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EnvironmentImport(environmentIn: EnvironmentIn, idempotencyKey?: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EnvironmentImport(environmentIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EnvironmentImport(rsp)));
            }));
    }
 
}

import { EnvironmentSettingsApiRequestFactory, EnvironmentSettingsApiResponseProcessor} from "../apis/EnvironmentSettingsApi";
export class ObservableEnvironmentSettingsApi {
    private requestFactory: EnvironmentSettingsApiRequestFactory;
    private responseProcessor: EnvironmentSettingsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: EnvironmentSettingsApiRequestFactory,
        responseProcessor?: EnvironmentSettingsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new EnvironmentSettingsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new EnvironmentSettingsApiResponseProcessor();
    }

    /**
     * Get the environment's settings
     * Get Org Settings
     */
    public v1EnvironmentGetSettings(_options?: Configuration): Observable<EnvironmentSettingsOut> {
        const requestContextPromise = this.requestFactory.v1EnvironmentGetSettings(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EnvironmentGetSettings(rsp)));
            }));
    }
 
}

import { EventTypeApiRequestFactory, EventTypeApiResponseProcessor} from "../apis/EventTypeApi";
export class ObservableEventTypeApi {
    private requestFactory: EventTypeApiRequestFactory;
    private responseProcessor: EventTypeApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: EventTypeApiRequestFactory,
        responseProcessor?: EventTypeApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new EventTypeApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new EventTypeApiResponseProcessor();
    }

    /**
     * Create new or unarchive existing event type.  Unarchiving an event type will allow endpoints to filter on it and messages to be sent with it. Endpoints filtering on the event type before archival will continue to filter on it. This operation does not preserve the description and schemas.
     * Create Event Type
     * @param eventTypeIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EventTypeCreate(eventTypeIn: EventTypeIn, idempotencyKey?: string, _options?: Configuration): Observable<EventTypeOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeCreate(eventTypeIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeCreate(rsp)));
            }));
    }
 
    /**
     * Archive an event type.  Endpoints already configured to filter on an event type will continue to do so after archival. However, new messages can not be sent with it and endpoints can not filter on it. An event type can be unarchived with the [create operation](#operation/create_event_type_api_v1_event_type__post).
     * Delete Event Type
     * @param eventTypeName The event type&#39;s name
     * @param expunge By default event types are archived when \&quot;deleted\&quot;. Passing this to &#x60;true&#x60; deletes them entirely.
     */
    public v1EventTypeDelete(eventTypeName: string, expunge?: boolean, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EventTypeDelete(eventTypeName, expunge, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeDelete(rsp)));
            }));
    }
 
    /**
     * Exports event type definitions based on the OpenAPI schemas associated with each existing event type
     * Event Type Export From Openapi
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EventTypeExportOpenapi(idempotencyKey?: string, _options?: Configuration): Observable<ExportEventTypeOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeExportOpenapi(idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeExportOpenapi(rsp)));
            }));
    }
 
    /**
     * Generates a fake example from the given JSONSchema
     * Generate Schema Example
     * @param eventTypeSchemaIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EventTypeGenerateExample(eventTypeSchemaIn: EventTypeSchemaIn, idempotencyKey?: string, _options?: Configuration): Observable<EventTypeExampleOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeGenerateExample(eventTypeSchemaIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeGenerateExample(rsp)));
            }));
    }
 
    /**
     * Get an event type.
     * Get Event Type
     * @param eventTypeName The event type&#39;s name
     */
    public v1EventTypeGet(eventTypeName: string, _options?: Configuration): Observable<EventTypeOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeGet(eventTypeName, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeGet(rsp)));
            }));
    }
 
    /**
     * Gets the retry schedule for messages using the given event type
     * Get Retry Schedule
     * @param eventTypeName The event type&#39;s name
     */
    public v1EventTypeGetRetrySchedule(eventTypeName: string, _options?: Configuration): Observable<RetryScheduleInOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeGetRetrySchedule(eventTypeName, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeGetRetrySchedule(rsp)));
            }));
    }
 
    /**
     * Given an OpenAPI spec, create new or update existing event types. If an existing `archived` event type is updated, it will be unarchived.  The importer will convert all webhooks found in the either the `webhooks` or `x-webhooks` top-level.
     * Event Type Import From Openapi
     * @param eventTypeImportOpenApiIn Import a list of event types from webhooks defined in an OpenAPI spec.  The OpenAPI spec can be specified as either &#x60;spec&#x60; given the spec as a JSON object, or as &#x60;specRaw&#x60; (a &#x60;string&#x60;) which will be parsed as YAML or JSON by the server. Sending neither or both is invalid, resulting in a &#x60;400&#x60; **Bad Request**.
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1EventTypeImportOpenapi(eventTypeImportOpenApiIn: EventTypeImportOpenApiIn, idempotencyKey?: string, _options?: Configuration): Observable<EventTypeImportOpenApiOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeImportOpenapi(eventTypeImportOpenApiIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeImportOpenapi(rsp)));
            }));
    }
 
    /**
     * Return the list of event types.
     * List Event Types
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     * @param includeArchived When &#x60;true&#x60; archived (deleted but not expunged) items are included in the response
     * @param withContent When &#x60;true&#x60; the full item (including the schema) is included in the response
     */
    public v1EventTypeList(limit?: number, iterator?: string, order?: Ordering, includeArchived?: boolean, withContent?: boolean, _options?: Configuration): Observable<ListResponseEventTypeOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeList(limit, iterator, order, includeArchived, withContent, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeList(rsp)));
            }));
    }
 
    /**
     * Partially update an event type.
     * Patch Event Type
     * @param eventTypeName The event type&#39;s name
     * @param eventTypePatch 
     */
    public v1EventTypePatch(eventTypeName: string, eventTypePatch: EventTypePatch, _options?: Configuration): Observable<EventTypeOut> {
        const requestContextPromise = this.requestFactory.v1EventTypePatch(eventTypeName, eventTypePatch, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypePatch(rsp)));
            }));
    }
 
    /**
     * Update an event type.
     * Update Event Type
     * @param eventTypeName The event type&#39;s name
     * @param eventTypeUpdate 
     */
    public v1EventTypeUpdate(eventTypeName: string, eventTypeUpdate: EventTypeUpdate, _options?: Configuration): Observable<EventTypeOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeUpdate(eventTypeName, eventTypeUpdate, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeUpdate(rsp)));
            }));
    }
 
    /**
     * Sets a retry schedule for all messages using the given event type
     * Update Retry Schedule
     * @param eventTypeName The event type&#39;s name
     * @param retryScheduleInOut 
     */
    public v1EventTypeUpdateRetrySchedule(eventTypeName: string, retryScheduleInOut: RetryScheduleInOut, _options?: Configuration): Observable<RetryScheduleInOut> {
        const requestContextPromise = this.requestFactory.v1EventTypeUpdateRetrySchedule(eventTypeName, retryScheduleInOut, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EventTypeUpdateRetrySchedule(rsp)));
            }));
    }
 
}

import { EventsApiRequestFactory, EventsApiResponseProcessor} from "../apis/EventsApi";
export class ObservableEventsApi {
    private requestFactory: EventsApiRequestFactory;
    private responseProcessor: EventsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: EventsApiRequestFactory,
        responseProcessor?: EventsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new EventsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new EventsApiResponseProcessor();
    }

    /**
     * Reads the stream of operational webhook events for this environment
     * Events
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param eventTypes Filter response based on the event type
     * @param channels Filter response based on the event type
     * @param after 
     */
    public v1Events(limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Observable<MessageEventsOut> {
        const requestContextPromise = this.requestFactory.v1Events(limit, iterator, eventTypes, channels, after, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1Events(rsp)));
            }));
    }
 
}

import { HealthApiRequestFactory, HealthApiResponseProcessor} from "../apis/HealthApi";
export class ObservableHealthApi {
    private requestFactory: HealthApiRequestFactory;
    private responseProcessor: HealthApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: HealthApiRequestFactory,
        responseProcessor?: HealthApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new HealthApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new HealthApiResponseProcessor();
    }

    /**
     * Verify the API server is up and running.
     * Health
     */
    public v1HealthGet(_options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1HealthGet(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1HealthGet(rsp)));
            }));
    }
 
}

import { InboundApiRequestFactory, InboundApiResponseProcessor} from "../apis/InboundApi";
export class ObservableInboundApi {
    private requestFactory: InboundApiRequestFactory;
    private responseProcessor: InboundApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: InboundApiRequestFactory,
        responseProcessor?: InboundApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new InboundApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new InboundApiResponseProcessor();
    }

    /**
     * Handles a raw inbound webhook for the application.
     * Handle Inbound
     * @param appId The app&#39;s ID or UID
     * @param inboundToken 
     * @param body 
     * @param eventType The event type&#39;s name
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1InboundMsg(appId: string, inboundToken: string, body: string, eventType?: string, idempotencyKey?: string, _options?: Configuration): Observable<MessageOut> {
        const requestContextPromise = this.requestFactory.v1InboundMsg(appId, inboundToken, body, eventType, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1InboundMsg(rsp)));
            }));
    }
 
    /**
     * Invalidates the previous inbound url (if one exists), producing a new inbound URL for this app
     * Rotate Url
     * @param appId The app&#39;s ID or UID
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1InboundRotateUrl(appId: string, idempotencyKey?: string, _options?: Configuration): Observable<RotatedUrlOut> {
        const requestContextPromise = this.requestFactory.v1InboundRotateUrl(appId, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1InboundRotateUrl(rsp)));
            }));
    }
 
}

import { IntegrationApiRequestFactory, IntegrationApiResponseProcessor} from "../apis/IntegrationApi";
export class ObservableIntegrationApi {
    private requestFactory: IntegrationApiRequestFactory;
    private responseProcessor: IntegrationApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: IntegrationApiRequestFactory,
        responseProcessor?: IntegrationApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new IntegrationApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new IntegrationApiResponseProcessor();
    }

    /**
     * Create an integration.
     * Create Integration
     * @param appId The app&#39;s ID or UID
     * @param integrationIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1IntegrationCreate(appId: string, integrationIn: IntegrationIn, idempotencyKey?: string, _options?: Configuration): Observable<IntegrationOut> {
        const requestContextPromise = this.requestFactory.v1IntegrationCreate(appId, integrationIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1IntegrationCreate(rsp)));
            }));
    }
 
    /**
     * Delete an integration.
     * Delete Integration
     * @param appId The app&#39;s ID or UID
     * @param integId The integ&#39;s ID
     */
    public v1IntegrationDelete(appId: string, integId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1IntegrationDelete(appId, integId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1IntegrationDelete(rsp)));
            }));
    }
 
    /**
     * Get an integration.
     * Get Integration
     * @param appId The app&#39;s ID or UID
     * @param integId The integ&#39;s ID
     */
    public v1IntegrationGet(appId: string, integId: string, _options?: Configuration): Observable<IntegrationOut> {
        const requestContextPromise = this.requestFactory.v1IntegrationGet(appId, integId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1IntegrationGet(rsp)));
            }));
    }
 
    /**
     * Get an integration's key.
     * Get Integration Key
     * @param appId The app&#39;s ID or UID
     * @param integId The integ&#39;s ID
     */
    public v1IntegrationGetKey(appId: string, integId: string, _options?: Configuration): Observable<IntegrationKeyOut> {
        const requestContextPromise = this.requestFactory.v1IntegrationGetKey(appId, integId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1IntegrationGetKey(rsp)));
            }));
    }
 
    /**
     * List the application's integrations.
     * List Integrations
     * @param appId The app&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     */
    public v1IntegrationList(appId: string, limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Observable<ListResponseIntegrationOut> {
        const requestContextPromise = this.requestFactory.v1IntegrationList(appId, limit, iterator, order, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1IntegrationList(rsp)));
            }));
    }
 
    /**
     * Rotate the integration's key. The previous key will be immediately revoked.
     * Rotate Integration Key
     * @param appId The app&#39;s ID or UID
     * @param integId The integ&#39;s ID
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1IntegrationRotateKey(appId: string, integId: string, idempotencyKey?: string, _options?: Configuration): Observable<IntegrationKeyOut> {
        const requestContextPromise = this.requestFactory.v1IntegrationRotateKey(appId, integId, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1IntegrationRotateKey(rsp)));
            }));
    }
 
    /**
     * Update an integration.
     * Update Integration
     * @param appId The app&#39;s ID or UID
     * @param integId The integ&#39;s ID
     * @param integrationUpdate 
     */
    public v1IntegrationUpdate(appId: string, integId: string, integrationUpdate: IntegrationUpdate, _options?: Configuration): Observable<IntegrationOut> {
        const requestContextPromise = this.requestFactory.v1IntegrationUpdate(appId, integId, integrationUpdate, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1IntegrationUpdate(rsp)));
            }));
    }
 
}

import { MessageApiRequestFactory, MessageApiResponseProcessor} from "../apis/MessageApi";
export class ObservableMessageApi {
    private requestFactory: MessageApiRequestFactory;
    private responseProcessor: MessageApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: MessageApiRequestFactory,
        responseProcessor?: MessageApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new MessageApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new MessageApiResponseProcessor();
    }

    /**
     * Creates and sends a message to the specified endpoint. The message attempt and response from the endpoint is returned. FIXME: use MessageIn for expediency, even though the `application` parameter is unused. Since this endpoint isn't publicly documented anyway, it should be fine
     * Create Message Attempt For Endpoint
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param messageIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public createMessageAttemptForEndpoint(appId: string, endpointId: string, messageIn: MessageIn, idempotencyKey?: string, _options?: Configuration): Observable<MessageAttemptOut> {
        const requestContextPromise = this.requestFactory.createMessageAttemptForEndpoint(appId, endpointId, messageIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.createMessageAttemptForEndpoint(rsp)));
            }));
    }
 
    /**
     * Creates a new message and dispatches it to all of the application's endpoints.  The `eventId` is an optional custom unique ID. It's verified to be unique only up to a day, after that no verification will be made. If a message with the same `eventId` already exists for the application, a 409 conflict error will be returned.  The `eventType` indicates the type and schema of the event. All messages of a certain `eventType` are expected to have the same schema. Endpoints can choose to only listen to specific event types. Messages can also have `channels`, which similar to event types let endpoints filter by them. Unlike event types, messages can have multiple channels, and channels don't imply a specific message content or schema.  The `payload` property is the webhook's body (the actual webhook message). Svix supports payload sizes of up to ~350kb, though it's generally a good idea to keep webhook payloads small, probably no larger than 40kb.
     * Create Message
     * @param appId The app&#39;s ID or UID
     * @param messageIn 
     * @param withContent When &#x60;true&#x60; message payloads are included in the response
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1MessageCreate(appId: string, messageIn: MessageIn, withContent?: boolean, idempotencyKey?: string, _options?: Configuration): Observable<MessageOut> {
        const requestContextPromise = this.requestFactory.v1MessageCreate(appId, messageIn, withContent, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageCreate(rsp)));
            }));
    }
 
    /**
     * Reads the stream of created messages for an application
     * Message Events
     * @param appId The app&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param eventTypes Filter response based on the event type
     * @param channels Filter response based on the event type
     * @param after 
     */
    public v1MessageEvents(appId: string, limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Observable<MessageEventsOut> {
        const requestContextPromise = this.requestFactory.v1MessageEvents(appId, limit, iterator, eventTypes, channels, after, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageEvents(rsp)));
            }));
    }
 
    /**
     * Reads the stream of created messages for an application, but using server-managed iterator tracking.
     * Message Events Subscription
     * @param appId The app&#39;s ID or UID
     * @param subscriptionId The esub&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param eventTypes Filter response based on the event type
     * @param channels Filter response based on the event type
     * @param after 
     */
    public v1MessageEventsSubscription(appId: string, subscriptionId: string, limit?: number, iterator?: string, eventTypes?: Array<string>, channels?: Array<string>, after?: Date, _options?: Configuration): Observable<MessageEventsOut> {
        const requestContextPromise = this.requestFactory.v1MessageEventsSubscription(appId, subscriptionId, limit, iterator, eventTypes, channels, after, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageEventsSubscription(rsp)));
            }));
    }
 
    /**
     * Creates an auth token that can be used with the `v1.message.events-subscription` endpoint
     * Message Events Create Token
     * @param appId The app&#39;s ID or UID
     * @param subscriptionId The esub&#39;s ID or UID
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1MessageEventsSubscriptionCreateToken(appId: string, subscriptionId: string, idempotencyKey?: string, _options?: Configuration): Observable<MessageSubscriberAuthTokenOut> {
        const requestContextPromise = this.requestFactory.v1MessageEventsSubscriptionCreateToken(appId, subscriptionId, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageEventsSubscriptionCreateToken(rsp)));
            }));
    }
 
    /**
     * Delete the given message's payload. Useful in cases when a message was accidentally sent with sensitive content.  The message can't be replayed or resent once its payload has been deleted or expired.
     * Delete message payload
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     */
    public v1MessageExpungeContent(appId: string, msgId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1MessageExpungeContent(appId, msgId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageExpungeContent(rsp)));
            }));
    }
 
    /**
     * Get a message by its ID or eventID.
     * Get Message
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param withContent When &#x60;true&#x60; message payloads are included in the response
     */
    public v1MessageGet(appId: string, msgId: string, withContent?: boolean, _options?: Configuration): Observable<MessageOut> {
        const requestContextPromise = this.requestFactory.v1MessageGet(appId, msgId, withContent, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageGet(rsp)));
            }));
    }
 
    /**
     * Get a message raw payload by its ID or eventID.
     * Get Raw Message Payload
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     */
    public v1MessageGetRawPayload(appId: string, msgId: string, _options?: Configuration): Observable<MessageRawPayloadOut> {
        const requestContextPromise = this.requestFactory.v1MessageGetRawPayload(appId, msgId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageGetRawPayload(rsp)));
            }));
    }
 
    /**
     * List all of the application's messages.  The `before` and `after` parameters let you filter all items created before or after a certain date. These can be used alongside an iterator to paginate over results within a certain window.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Messages
     * @param appId The app&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param channel Filter response based on the channel
     * @param before Only include items created before a certain date
     * @param after Only include items created after a certain date
     * @param withContent When &#x60;true&#x60; message payloads are included in the response
     * @param tag Filter messages matching the provided tag
     * @param eventTypes Filter response based on the event type
     */
    public v1MessageList(appId: string, limit?: number, iterator?: string, channel?: string, before?: Date, after?: Date, withContent?: boolean, tag?: string, eventTypes?: Array<string>, _options?: Configuration): Observable<ListResponseMessageOut> {
        const requestContextPromise = this.requestFactory.v1MessageList(appId, limit, iterator, channel, before, after, withContent, tag, eventTypes, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageList(rsp)));
            }));
    }
 
}

import { MessageAttemptApiRequestFactory, MessageAttemptApiResponseProcessor} from "../apis/MessageAttemptApi";
export class ObservableMessageAttemptApi {
    private requestFactory: MessageAttemptApiRequestFactory;
    private responseProcessor: MessageAttemptApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: MessageAttemptApiRequestFactory,
        responseProcessor?: MessageAttemptApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new MessageAttemptApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new MessageAttemptApiResponseProcessor();
    }

    /**
     * Deletes the given attempt's response body. Useful when an endpoint accidentally returned sensitive content.
     * Delete attempt response body
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param attemptId The attempt&#39;s ID
     */
    public v1MessageAttemptExpungeContent(appId: string, msgId: string, attemptId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptExpungeContent(appId, msgId, attemptId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptExpungeContent(rsp)));
            }));
    }
 
    /**
     * `msg_id`: Use a message id or a message `eventId`
     * Get Attempt
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param attemptId The attempt&#39;s ID
     */
    public v1MessageAttemptGet(appId: string, msgId: string, attemptId: string, _options?: Configuration): Observable<MessageAttemptOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptGet(appId, msgId, attemptId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptGet(rsp)));
            }));
    }
 
    /**
     * Calculate and return headers used on a given message attempt
     * Get Attempt Headers
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param attemptId The attempt&#39;s ID
     */
    public v1MessageAttemptGetHeaders(appId: string, msgId: string, attemptId: string, _options?: Configuration): Observable<MessageAttemptHeadersOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptGetHeaders(appId, msgId, attemptId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptGetHeaders(rsp)));
            }));
    }
 
    /**
     * List endpoints attempted by a given message. Additionally includes metadata about the latest message attempt. By default, endpoints are listed in ascending order by ID.
     * List Attempted Destinations
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     */
    public v1MessageAttemptListAttemptedDestinations(appId: string, msgId: string, limit?: number, iterator?: string, _options?: Configuration): Observable<ListResponseMessageEndpointOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptListAttemptedDestinations(appId, msgId, limit, iterator, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptListAttemptedDestinations(rsp)));
            }));
    }
 
    /**
     * List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempted Messages
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param channel Filter response based on the channel
     * @param tag Filter response based on the message tags
     * @param status Filter response based on the delivery status
     * @param before Only include items created before a certain date
     * @param after Only include items created after a certain date
     * @param withContent When &#x60;true&#x60; message payloads are included in the response
     * @param eventTypes Filter response based on the event type
     */
    public v1MessageAttemptListAttemptedMessages(appId: string, endpointId: string, limit?: number, iterator?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, withContent?: boolean, eventTypes?: Array<string>, _options?: Configuration): Observable<ListResponseEndpointMessageOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptListAttemptedMessages(appId, endpointId, limit, iterator, channel, tag, status, before, after, withContent, eventTypes, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptListAttemptedMessages(rsp)));
            }));
    }
 
    /**
     * List attempts by endpoint id  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts By Endpoint
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param status Filter response based on the delivery status
     * @param statusCodeClass Filter response based on the HTTP status code
     * @param channel Filter response based on the channel
     * @param tag Filter response based on the tag
     * @param before Only include items created before a certain date
     * @param after Only include items created after a certain date
     * @param withContent When &#x60;true&#x60; attempt content is included in the response
     * @param withMsg When &#x60;true&#x60;, the message information is included in the response
     * @param eventTypes Filter response based on the event type
     */
    public v1MessageAttemptListByEndpoint(appId: string, endpointId: string, limit?: number, iterator?: string, status?: MessageStatus, statusCodeClass?: StatusCodeClass, channel?: string, tag?: string, before?: Date, after?: Date, withContent?: boolean, withMsg?: boolean, eventTypes?: Array<string>, _options?: Configuration): Observable<ListResponseMessageAttemptOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptListByEndpoint(appId, endpointId, limit, iterator, status, statusCodeClass, channel, tag, before, after, withContent, withMsg, eventTypes, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptListByEndpoint(rsp)));
            }));
    }
 
    /**
     * DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts For Endpoint
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param channel Filter response based on the channel
     * @param tag Filter response based on the tag
     * @param status Filter response based on the delivery status
     * @param before Only include items created before a certain date
     * @param after Only include items created after a certain date
     * @param eventTypes Filter response based on the event type
     */
    public v1MessageAttemptListByEndpointDeprecated(appId: string, msgId: string, endpointId: string, limit?: number, iterator?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, eventTypes?: Array<string>, _options?: Configuration): Observable<ListResponseMessageAttemptEndpointOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptListByEndpointDeprecated(appId, msgId, endpointId, limit, iterator, channel, tag, status, before, after, eventTypes, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptListByEndpointDeprecated(rsp)));
            }));
    }
 
    /**
     * List attempts by message id  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
     * List Attempts By Msg
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param status Filter response based on the delivery status
     * @param statusCodeClass Filter response based on the HTTP status code
     * @param channel Filter response based on the channel
     * @param tag Filter response based on the tag
     * @param endpointId Filter the attempts based on the attempted endpoint
     * @param before Only include items created before a certain date
     * @param after Only include items created after a certain date
     * @param withContent When &#x60;true&#x60; attempt content is included in the response
     * @param eventTypes Filter response based on the event type
     */
    public v1MessageAttemptListByMsg(appId: string, msgId: string, limit?: number, iterator?: string, status?: MessageStatus, statusCodeClass?: StatusCodeClass, channel?: string, tag?: string, endpointId?: string, before?: Date, after?: Date, withContent?: boolean, eventTypes?: Array<string>, _options?: Configuration): Observable<ListResponseMessageAttemptOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptListByMsg(appId, msgId, limit, iterator, status, statusCodeClass, channel, tag, endpointId, before, after, withContent, eventTypes, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptListByMsg(rsp)));
            }));
    }
 
    /**
     * Deprecated: Please use \"List Attempts by Endpoint\" and \"List Attempts by Msg\" instead.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate.  `msg_id`: Use a message id or a message `eventId`
     * List Attempts
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param endpointId Filter the attempts based on the attempted endpoint
     * @param channel Filter response based on the channel
     * @param tag Filter response based on the tag
     * @param status Filter response based on the delivery status
     * @param before Only include items created before a certain date
     * @param after Only include items created after a certain date
     * @param statusCodeClass Filter response based on the HTTP status code
     * @param eventTypes Filter response based on the event type
     */
    public v1MessageAttemptListByMsgDeprecated(appId: string, msgId: string, limit?: number, iterator?: string, endpointId?: string, channel?: string, tag?: string, status?: MessageStatus, before?: Date, after?: Date, statusCodeClass?: StatusCodeClass, eventTypes?: Array<string>, _options?: Configuration): Observable<ListResponseMessageAttemptOut> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptListByMsgDeprecated(appId, msgId, limit, iterator, endpointId, channel, tag, status, before, after, statusCodeClass, eventTypes, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptListByMsgDeprecated(rsp)));
            }));
    }
 
    /**
     * Resend a message to the specified endpoint.
     * Resend Webhook
     * @param appId The app&#39;s ID or UID
     * @param msgId The msg&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1MessageAttemptResend(appId: string, msgId: string, endpointId: string, idempotencyKey?: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1MessageAttemptResend(appId, msgId, endpointId, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1MessageAttemptResend(rsp)));
            }));
    }
 
}

import { SinkApiRequestFactory, SinkApiResponseProcessor} from "../apis/SinkApi";
export class ObservableSinkApi {
    private requestFactory: SinkApiRequestFactory;
    private responseProcessor: SinkApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: SinkApiRequestFactory,
        responseProcessor?: SinkApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new SinkApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new SinkApiResponseProcessor();
    }

    /**
     * Creates streaming events.
     * Append To Stream
     * @param streamId 
     * @param createStreamIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1StreamCreateEvents(streamId: string, createStreamIn: CreateStreamIn, idempotencyKey?: string, _options?: Configuration): Observable<any> {
        const requestContextPromise = this.requestFactory.v1StreamCreateEvents(streamId, createStreamIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamCreateEvents(rsp)));
            }));
    }
 
    /**
     * Iterate over a stream of events.
     * Stream Events
     * @param streamId 
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param after 
     */
    public v1StreamEventsGet(streamId: string, limit?: number, iterator?: string, after?: Date, _options?: Configuration): Observable<EventStreamOut> {
        const requestContextPromise = this.requestFactory.v1StreamEventsGet(streamId, limit, iterator, after, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamEventsGet(rsp)));
            }));
    }
 
}

import { StatisticsApiRequestFactory, StatisticsApiResponseProcessor} from "../apis/StatisticsApi";
export class ObservableStatisticsApi {
    private requestFactory: StatisticsApiRequestFactory;
    private responseProcessor: StatisticsApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: StatisticsApiRequestFactory,
        responseProcessor?: StatisticsApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new StatisticsApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new StatisticsApiResponseProcessor();
    }

    /**
     * Creates a background task to calculate the message destinations for all applications in the environment.  Note that this endpoint is asynchronous. You will need to poll the `Get Background Task` endpoint to retrieve the results of the operation.
     * Aggregate App Stats
     * @param appUsageStatsIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1StatisticsAggregateAppStats(appUsageStatsIn: AppUsageStatsIn, idempotencyKey?: string, _options?: Configuration): Observable<AppUsageStatsOut> {
        const requestContextPromise = this.requestFactory.v1StatisticsAggregateAppStats(appUsageStatsIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StatisticsAggregateAppStats(rsp)));
            }));
    }
 
    /**
     * Creates a background task to calculate the listed event types for all apps in the organization.  Note that this endpoint is asynchronous. You will need to poll the `Get Background Task` endpoint to retrieve the results of the operation.
     * Aggregate Event Types
     */
    public v1StatisticsAggregateEventTypes(_options?: Configuration): Observable<AggregateEventTypesOut> {
        const requestContextPromise = this.requestFactory.v1StatisticsAggregateEventTypes(_options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StatisticsAggregateEventTypes(rsp)));
            }));
    }
 
    /**
     * Returns application-level statistics on message attempts
     * Get App Attempt Stats
     * @param appId The app&#39;s ID or UID
     * @param startDate Filter the range to data starting from this date
     * @param endDate Filter the range to data ending by this date
     */
    public v1StatsAppAttempts(appId: string, startDate?: Date, endDate?: Date, _options?: Configuration): Observable<AttemptStatisticsResponse> {
        const requestContextPromise = this.requestFactory.v1StatsAppAttempts(appId, startDate, endDate, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StatsAppAttempts(rsp)));
            }));
    }
 
    /**
     * Returns endpoint-level statistics on message attempts
     * Get Ep Stats
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param startDate Filter the range to data starting from this date
     * @param endDate Filter the range to data ending by this date
     */
    public v1StatsEndpointAttempts(appId: string, endpointId: string, startDate?: Date, endDate?: Date, _options?: Configuration): Observable<AttemptStatisticsResponse> {
        const requestContextPromise = this.requestFactory.v1StatsEndpointAttempts(appId, endpointId, startDate, endDate, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StatsEndpointAttempts(rsp)));
            }));
    }
 
}

import { StreamApiRequestFactory, StreamApiResponseProcessor} from "../apis/StreamApi";
export class ObservableStreamApi {
    private requestFactory: StreamApiRequestFactory;
    private responseProcessor: StreamApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: StreamApiRequestFactory,
        responseProcessor?: StreamApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new StreamApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new StreamApiResponseProcessor();
    }

    /**
     * Creates a new stream.
     * Create Stream
     * @param streamIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1StreamCreate(streamIn: StreamIn, idempotencyKey?: string, _options?: Configuration): Observable<StreamOut> {
        const requestContextPromise = this.requestFactory.v1StreamCreate(streamIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamCreate(rsp)));
            }));
    }
 
    /**
     * Delete a stream.
     * Delete Stream
     * @param streamId 
     */
    public v1StreamDelete(streamId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1StreamDelete(streamId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamDelete(rsp)));
            }));
    }
 
    /**
     * Get a stream by id or uid.
     * Get Stream
     * @param streamId 
     */
    public v1StreamGet(streamId: string, _options?: Configuration): Observable<StreamOut> {
        const requestContextPromise = this.requestFactory.v1StreamGet(streamId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamGet(rsp)));
            }));
    }
 
    /**
     * List of all the organization's streams.
     * List Streams
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     */
    public v1StreamList(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Observable<ListResponseStreamOut> {
        const requestContextPromise = this.requestFactory.v1StreamList(limit, iterator, order, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamList(rsp)));
            }));
    }
 
    /**
     * Partially update a stream.
     * Patch Stream
     * @param streamId 
     * @param streamPatch 
     */
    public v1StreamPatch(streamId: string, streamPatch: StreamPatch, _options?: Configuration): Observable<StreamOut> {
        const requestContextPromise = this.requestFactory.v1StreamPatch(streamId, streamPatch, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamPatch(rsp)));
            }));
    }
 
    /**
     * Update a stream.
     * Update Stream
     * @param streamId 
     * @param streamIn 
     */
    public v1StreamUpdate(streamId: string, streamIn: StreamIn, _options?: Configuration): Observable<StreamOut> {
        const requestContextPromise = this.requestFactory.v1StreamUpdate(streamId, streamIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1StreamUpdate(rsp)));
            }));
    }
 
}

import { TransformationTemplateApiRequestFactory, TransformationTemplateApiResponseProcessor} from "../apis/TransformationTemplateApi";
export class ObservableTransformationTemplateApi {
    private requestFactory: TransformationTemplateApiRequestFactory;
    private responseProcessor: TransformationTemplateApiResponseProcessor;
    private configuration: Configuration;

    public constructor(
        configuration: Configuration,
        requestFactory?: TransformationTemplateApiRequestFactory,
        responseProcessor?: TransformationTemplateApiResponseProcessor
    ) {
        this.configuration = configuration;
        this.requestFactory = requestFactory || new TransformationTemplateApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new TransformationTemplateApiResponseProcessor();
    }

    /**
     * Create/update endpoint Hubsport OAuth configuration Specific private endpoint just for us, to avoid exposing the Hubspot secret to the client.
     * Update Hubspot Oauth Config
     * @param appId The app&#39;s ID or UID
     * @param endpointId The ep&#39;s ID or UID
     * @param hubspotOauthConfigIn 
     */
    public v1EndpointUpdateHubspotOauthConfig(appId: string, endpointId: string, hubspotOauthConfigIn: HubspotOauthConfigIn, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1EndpointUpdateHubspotOauthConfig(appId, endpointId, hubspotOauthConfigIn, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1EndpointUpdateHubspotOauthConfig(rsp)));
            }));
    }
 
    /**
     * Create a new transformation template
     * Create Transformation Template
     * @param templateIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1TransformationTemplateCreate(templateIn: TemplateIn, idempotencyKey?: string, _options?: Configuration): Observable<TemplateOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateCreate(templateIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateCreate(rsp)));
            }));
    }
 
    /**
     * Delete a transformation template
     * Delete Transformation Template
     * @param transformationTemplateId 
     */
    public v1TransformationTemplateDelete(transformationTemplateId: string, _options?: Configuration): Observable<void> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateDelete(transformationTemplateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateDelete(rsp)));
            }));
    }
 
    /**
     * Use OpenAI's Completion API to generate code for a transformation template
     * Generate
     * @param generateIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1TransformationTemplateGenerate(generateIn: GenerateIn, idempotencyKey?: string, _options?: Configuration): Observable<GenerateOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateGenerate(generateIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateGenerate(rsp)));
            }));
    }
 
    /**
     * Get a transformation template
     * Get Transformation Template
     * @param transformationTemplateId 
     */
    public v1TransformationTemplateGet(transformationTemplateId: string, _options?: Configuration): Observable<TemplateOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateGet(transformationTemplateId, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateGet(rsp)));
            }));
    }
 
    /**
     * List all transformation templates for an application
     * List Transformation Templates
     * @param limit Limit the number of returned items
     * @param iterator The iterator returned from a prior invocation
     * @param order The sorting order of the returned items
     */
    public v1TransformationTemplateList(limit?: number, iterator?: string, order?: Ordering, _options?: Configuration): Observable<ListResponseTemplateOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateList(limit, iterator, order, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateList(rsp)));
            }));
    }
 
    /**
     * Get Discord Incoming webhook URL
     * Authorize Discord
     * @param oAuthPayloadIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1TransformationTemplateOauthDiscord(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Observable<IncomingWebhookPayloadOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateOauthDiscord(oAuthPayloadIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateOauthDiscord(rsp)));
            }));
    }
 
    /**
     * Get Hubspot access token using authorization code
     * Authorize Hubspot
     * @param oAuthPayloadIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1TransformationTemplateOauthHubspot(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Observable<OAuthPayloadOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateOauthHubspot(oAuthPayloadIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateOauthHubspot(rsp)));
            }));
    }
 
    /**
     * Get Slack Incoming webhook URL
     * Authorize Slack
     * @param oAuthPayloadIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1TransformationTemplateOauthSlack(oAuthPayloadIn: OAuthPayloadIn, idempotencyKey?: string, _options?: Configuration): Observable<IncomingWebhookPayloadOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateOauthSlack(oAuthPayloadIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateOauthSlack(rsp)));
            }));
    }
 
    /**
     * Partially update a transformation template
     * Patch Transformation Template
     * @param transformationTemplateId 
     * @param templatePatch 
     */
    public v1TransformationTemplatePatch(transformationTemplateId: string, templatePatch: TemplatePatch, _options?: Configuration): Observable<TemplateOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplatePatch(transformationTemplateId, templatePatch, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplatePatch(rsp)));
            }));
    }
 
    /**
     * Simulate running the transformation on the payload and code
     * Simulate
     * @param transformationSimulateIn 
     * @param idempotencyKey The request&#39;s idempotency key
     */
    public v1TransformationTemplateSimulate(transformationSimulateIn: TransformationSimulateIn, idempotencyKey?: string, _options?: Configuration): Observable<TransformationSimulateOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateSimulate(transformationSimulateIn, idempotencyKey, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateSimulate(rsp)));
            }));
    }
 
    /**
     * Update a transformation template
     * Update Transformation Template
     * @param transformationTemplateId 
     * @param templateUpdate 
     */
    public v1TransformationTemplateUpdate(transformationTemplateId: string, templateUpdate: TemplateUpdate, _options?: Configuration): Observable<TemplateOut> {
        const requestContextPromise = this.requestFactory.v1TransformationTemplateUpdate(transformationTemplateId, templateUpdate, _options);

        // build promise chain
        let middlewarePreObservable = from<RequestContext>(requestContextPromise);
        for (let middleware of this.configuration.middleware) {
            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));
        }

        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).
            pipe(mergeMap((response: ResponseContext) => {
                let middlewarePostObservable = of(response);
                for (let middleware of this.configuration.middleware) {
                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));
                }
                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.v1TransformationTemplateUpdate(rsp)));
            }));
    }
 
}
